
local plr = game:GetService("Players")
local lp = plr.LocalPlayer
local http = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request
local TeleportService = game:GetService("TeleportService")

-- å­˜å‚¨ç¬¦åˆæ¡ä»¶çš„æœåŠ¡å™¨åˆ—è¡¨
local servers = {}

-- å‘Roblox APIå‘é€è¯·æ±‚è·å–æœåŠ¡å™¨åˆ—è¡¨
local function fetchServerList()
    local url = string.format("https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Asc&limit=100", game.PlaceId)
    local req, err = http({
        Url = url
    })
    
    if not req or req.StatusCode ~= 200 then
        warn("Failed to fetch server list:", err or "Unknown error")
        warn("URL used:", url)
        warn("Status Code:", req and req.StatusCode or "N/A")
        return false
    end
    
    local success, body = pcall(function()
        return game:GetService("HttpService"):JSONDecode(req.Body)
    end)
    
    if not success or not body or not body.data then
        warn("Invalid response from API:", req.Body)
        return false
    end
    
    -- æ¸…ç©ºæ—§æœåŠ¡å™¨åˆ—è¡¨
    servers = {}
    
    for _, v in ipairs(body.data) do
        if v.playing < v.maxPlayers and v.id ~= game.JobId then
            table.insert(servers, v)
        end
    end
    
    return true
end

-- æ‰¾åˆ°ç©å®¶æœ€å°‘çš„æœåŠ¡å™¨
local function findLeastPopulatedServer()
    if #servers == 0 then
        warn("No available servers found.")
        return nil
    end
    
    local leastPopulatedServer = servers[1]
    for _, v in ipairs(servers) do
        if v.playing < leastPopulatedServer.playing then
            leastPopulatedServer = v
        end
    end
    
    return leastPopulatedServer.id
end

-- å¤„ç†æ¢æœ
local function teleportToServer(serverId)
    local success, err = pcall(function()
        TeleportService:TeleportToPlaceInstance(game.PlaceId, serverId, lp)
    end)
    
    if not success then
        warn("Teleport failed:", err)
        return false
    end
    return true
end

-- ä¸»é€»è¾‘
local function main()
    if not fetchServerList() then
        warn("Failed to fetch server list. Will retry later.")
        return false
    end
    
    if #servers == 0 then
        warn("No available servers found.")
        return false
    end
    
    warn("Available servers count:", #servers)
    local targetServerId = findLeastPopulatedServer()
    
    if not targetServerId then
        warn("No suitable server found.")
        return false
    end
    
    warn("Attempting to teleport to server:", targetServerId)
    return teleportToServer(targetServerId)
end

-- è‡ªåŠ¨æ‰§è¡Œä¸»é€»è¾‘
local function autoTeleport()
    while true do
        warn("Starting server check...")
        
        local success = main()
        if success then
            warn("Teleport initiated. Waiting for completion...")
            -- ç­‰å¾…è¶³å¤Ÿæ—¶é—´è®©ä¼ é€å®Œæˆ
            wait(30)
        else
            warn("Teleport not initiated. Will retry in 15 seconds...")
            wait(15)
        end
    end
end

-- è·å–ç©å®¶æœåŠ¡
local plr = game:GetService("Players") 
-- è·å–æœ¬åœ°ç©å®¶
local lp = plr.LocalPlayer 
-- è·å–ç©å®¶è§’è‰²
local cha = lp.Character 
-- è·å–è§’è‰²çš„äººå½¢ç»„ä»¶
local hum = cha.Humanoid 
-- è·å–è§’è‰²çš„æ ¹éƒ¨ä½
local humd = cha.HumanoidRootPart 

-- å®šä¹‰ä¼ é€å‡½æ•°
local function tp(pos)
    -- å°†è§’è‰²ä¼ é€åˆ°æŒ‡å®šä½ç½®
    humd.CFrame = pos
end

-- å®šä¹‰è·å–éƒ¨ä»¶å’Œç‚¹å‡»æ£€æµ‹å™¨çš„å‡½æ•°
local function getprandde(newpart)
    local part, del -- part: éƒ¨ä»¶å¯¹è±¡, del: ç‚¹å‡»æ£€æµ‹å™¨
    -- éå†ç‰©å“çš„æ‰€æœ‰å­å¯¹è±¡
    for i, v in next, newpart:GetDescendants() do
        if v.ClassName == 'ClickDetector' then
            del = v -- å­˜å‚¨ç‚¹å‡»æ£€æµ‹å™¨
        elseif v.ClassName == 'Part' then
            part = v -- å­˜å‚¨éƒ¨ä»¶å¯¹è±¡
        end
    end
    return part, del
end

-- æ¨¡æ‹ŸæŒ‰ä¸‹Wé”®1ç§’ï¼ˆå¯èƒ½æ˜¯ä¸ºäº†æ¿€æ´»æŸäº›æœºåˆ¶ï¼‰
game:GetService("VirtualInputManager"):SendKeyEvent(true, "W", false, game)
wait(1)
game:GetService("VirtualInputManager"):SendKeyEvent(false, "W", false, game)
        
wait(2)--åˆ·æ–°
-- å®šä¹‰æ‹¾å–ç‰©å“çš„å‡½æ•°
local function getitem(item)
    -- è·å–ç‰©å“çš„éƒ¨ä»¶å’Œç‚¹å‡»æ£€æµ‹å™¨
    local part, delic = getprandde(item)
    if part then -- å¦‚æœæ‰¾åˆ°æœ‰æ•ˆéƒ¨ä»¶
        local count = 0 -- å°è¯•æ¬¡æ•°è®¡æ•°å™¨
        -- ä¼ é€åˆ°ç‰©å“ä¸Šæ–¹5å•ä½å¤„
        tp(part.CFrame + Vector3.new(0, 5, 0))
        repeat
            task.wait(.2)
            count = count + 1
            -- æ¨¡æ‹ŸæŒ‰ä¸‹Eé”®ï¼ˆæ‹¾å–åŠ¨ä½œï¼‰
            game:GetService("VirtualInputManager"):SendKeyEvent(true, "E", false, game)
            wait(1)
            game:GetService("VirtualInputManager"):SendKeyEvent(false, "E", false, game)
        until item.Parent == nil or count > 10 -- ç›´åˆ°ç‰©å“è¢«æ‹¾å–æˆ–å°è¯•è¶…è¿‡10æ¬¡
        task.wait()
    end
end

    for i, v in next, workspace.Game.Entities.ItemPickup:GetChildren() do
        -- æ£€æŸ¥ç‰©å“å°ºå¯¸æ˜¯å¦ç¬¦åˆç‰¹å®šæ¡ä»¶ï¼ˆ2.684725046157837, 2.196493148803711, 2.5559489727020264ï¼‰
        if v:FindFirstChildOfClass('Part', true).Size ==
            Vector3.new(2.684725046157837, 2.196493148803711, 2.5559489727020264) then
            getitem(v) -- å°è¯•æ‹¾å–è¯¥ç‰©å“
            task.wait()
        end
    end
    game:GetService("StarterGui"):SetCore("SendNotification",{
	    Title = "ğŸ’lyyè‡ªåŠ¨æ‹¾å–å°é’æœºğŸ’";
	    Text = "èµåŠ©è€… é›¾éœ¾ éœ½ å†‰ Fly åç§‹ pico é¨¹æ¦ æˆ‘çš„æ©äºº:ğŸ”®æ®‹å°é›ªğŸ”®";
	    Duration = 5;
		
        })
        
wait(2)--æ¢æœåŠ¡å™¨é—´éš”
autoTeleport()
